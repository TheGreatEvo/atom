// Free to modify variables
num leafRadius = 3 + randomInt(4);
num trunkHeight = 5 + randomInt(5);
num leafTopHeight = trunkHeight * 1.3;
num leafBottomHeight = 1 + randomInt(2);
str trunkBlockX = "minecraft:oak_log[axis=x]";
str trunkBlockY = "minecraft:oak_log[axis=y]";
str trunkBlockZ = "minecraft:oak_log[axis=z]";
str leafBlock   = "minecraft:oak_leaves[distance=1,persistent=false]";
str stick1 = "craftengine:custom_3";
str stick2 = "craftengine:custom_4";
str stick3 = "craftengine:custom_5";

// Tree gen logic
num leafMidPointRatio = 0.25;
num leafMidHeight = leafBottomHeight + (leafTopHeight - leafBottomHeight) * leafMidPointRatio;
for (num y = 0; y <= leafTopHeight; y = y + 1) {
    num radius = 0;

    // Radius formula - Two parabolas that intersect at the variables above
    if (y < leafMidHeight) {
        radius = (-pow((y - leafMidHeight) / (leafBottomHeight - leafMidHeight), 2) + 1) * leafRadius;
    } else {
        radius = (-pow((y - leafMidHeight) / (leafTopHeight - leafMidHeight), 2) + 1) * leafRadius;
    }

    if (y >= leafBottomHeight) {
        if (radius <= 1) {
            // Skip generating circle if radius is less than 1
            block(0, y, 0, leafBlock);
        } else {
            // Generate circle of leaves at y level
            num squareradius = radius * radius; // Square the radius to avoid unnecessary square root when comparing dist
            for (num x = round(-radius); x <= round(radius); x = x + 1) {
                for (num z = round(-radius); z <= round(radius); z = z + 1) {
                    num squaredist = x * x + z * z;
                    if (squaredist <= squareradius) {
                        if (squareradius - squaredist < squareradius * 0.4) {
                            // If close to edge, make fuzzy
                            if (randomInt(2) == 0) {
                                block(x, y, z, leafBlock, false);
                            }
                        } else {
                            block(x, y, z, leafBlock, false);
                        }
                    }
                }
            }
        }
    }

    if (y <= trunkHeight) {
        // Generating a tree branch
        if (radius > 4 && randomInt(2) == 0) {
            // Pick either X or Z axis
            num xdir = 1;
            num zdir = 0;
            str branchBlock = trunkBlockX;
            if (randomInt(2) == 1) {
                xdir = 0;
                zdir = 1;
                branchBlock = trunkBlockZ;
            }
            // Pick if negative of positive in axis
            num sign = 1;
            if (randomInt(2) == 0) sign = -1;
            // If there isn't already a branch directly below, generate a branch
            if (getMark(xdir * sign, y - 1, zdir * sign) != "branch") {
                for (num i = 1; i < radius - 1.5; i = i + 1) {
                    // These generate in a straight line so it's not annoying to chop
                    block(i * xdir * sign, y, i * zdir * sign, branchBlock);
                    setMark(i * xdir * sign, y, i * zdir * sign, "branch");
                }
            }
        }
        block(0, y, 0, trunkBlockY); // Main trunk
    }
}

num beeNestRoll = randomInt(30); // 1 in 30 chance
if (beeNestRoll == 0) {
    structure(0, leafBottomHeight, 0, "bee_nest", "NONE");
}

block(0, -1, 0, "minecraft:dirt");
block(0, 0, 1, stick1);

// --- Random sticks around base ---
// Config: max sticks and rarity control (higher = rarer)
num maxSticks = 4;
num attempts = 40;           // how many placement tries to find up to maxSticks
num baseRadius = 6;          // search radius around trunk at ground level
num rareScale = 1;          // higher number = rarer overall spawns

num placed = 0;
for (num t = 0; t < attempts && placed < maxSticks; t = t + 1) {
    // Sample a candidate position with distance bias toward trunk.
    // Use "rejection sampling": pick within square, reject outside circle sometimes.
    num x = randomInt(baseRadius * 2 + 1) - baseRadius; // [-R, R]
    num z = randomInt(baseRadius * 2 + 1) - baseRadius;

    // Skip the trunk center
    if (x == 0 && z == 0) continue;

    // Compute squared distance and bias probability:
    // Closer to center => higher chance. Farther => lower chance.
    num d2 = x * x + z * z;
    num r2 = baseRadius * baseRadius;
    // if (d2 > r2) continue;

    // Distance bias: probNear ranges from ~1 near center to small near edge
    // Using a smooth falloff curve (quadratic)
    num probNearScaled = (r2 - d2) / r2;          // 1.0 at center, ~0 at edge
    num probPermille = floor(probNearScaled * 1000); // 0..1000

    // Add overall rarity gate
    // Effective chance ~ probNearScaled / rareScale
    // if (randomInt(rareScale * 1000) >= probPermille) continue;

    // Randomly choose one of the stick variants
    num which = randomInt(3); // 0,1,2
    str stickBlock = stick1;
    if (which == 1) stickBlock = stick2;
    if (which == 2) stickBlock = stick3;

    // Check placement conditions based on y-level
    // Check y = 0
    if (getBlock(x, 0, z) != "minecraft:air") {
        // If there's a solid block at 0, check if there's air at 1
        if (getBlock(x, 1, z) == "minecraft:air" && structure(x, 0, z, "is_solid", "NONE")) {
            // Place at y = 1
            block(x, 1, z, stickBlock);
            placed = placed + 1;
            continue;
        }
    } else if (getBlock(x, 0, z) == "minecraft:air") {
        if(structure(x, -1, z, "is_solid", "NONE")) {
            // Place at y = 0 if there's air
            block(x, 0, z, stickBlock);
            placed = placed + 1;
            continue;
        }
    } else if (getBlock(x, -1, z) == "minecraft:air" && structure(x, -2, z, "is_solid", "NONE")) {
        // Otherwise try placing at y = -1 if there's support
        block(x, -1, z, stickBlock);
        placed = placed + 1;
        continue;
    }
}